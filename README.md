# Springboot

## 스프링(Spring)과 스프링 부트(Spring Boot)와의 차이점

- 스프링(Spring)

  -  스프링은 원래부터 자바 기반의 애플리케이션을 개발하기 위한 포괄적인 프레임워크입니다.
  -  스프링은 다양한 모듈로 구성되어 있으며, 웹 개발, 데이터 액세스, 보안, 트랜잭션 관리 등 다양한 영역을 다루는 기능을 제공합니다.
  -  개발자는 각 모듈을 필요에 따라 선택하여 구성할 수 있습니다. 이에 따라 복잡한 설정이 요구될 수 있습니다.
  -  스프링 애플리케이션의 설정과 구성을 자세하게 다루며, 개발자가 세밀하게 컨트롤할 수 있습니다.

- 스프링 부트(Spring Boot)

  -  스프링 부트는 스프링의 복잡한 설정을 최소화하고, 간단하고 빠르게 스프링 기반의 애플리케이션을 개발하기 위해 만들어진 프로젝트입니다.
  -  내장된 설정 기본값들로 인해 개발자가 별도의 설정 없이도 빠르게 시작할 수 있습니다.
  -  스프링 부트는 "컨벤션 오버 구성(Convention over Configuration)" 원칙을 따르며, 일반적인 애플리케이션 개발을 위한 기본 설정을 제공합니다.
  -  내장된 서버 (예: Tomcat, Jetty) 덕분에 애플리케이션 배포가 간단하고 포터블합니다.
  -  스프링 부트 스타터 패키지를 통해 필요한 의존성들을 간단하게 추가할 수 있습니다.
    
-----------------------------------------------------
  
요약하자면, 스프링은 보다 복잡하고 다양한 기능을 다루는 프레임워크이며, 개발자가 모듈을 선택하고 설정을 세밀하게 다루어야 합니다. 

  반면에 스프링 부트는 스프링의 복잡한 설정을 간소화하고, 애플리케이션의 빠른 개발과 배포를 위한 기능을 중점으로 하는 프로젝트입니다. 
  
  선택은 프로젝트의 요구사항과 개발자의 선호도에 따라 다를 수 있습니다.
  
  -----------------------------------------------------

  ## 스프링부트의 장점



  - 자동 설정(Auto Configuration)
    
    - 스프링 부트는 애플리케이션의 의존성을 분석하여 적절한 설정을 자동으로 제공합니다.
      
       개발자가 수동으로 설정해야 하는 부분을 최소화하고, 기본적인 설정을 제공하여 개발 속도를 향상시킵니다.
  
  - 스타터(Starter) 패키지
    
    - 스프링 부트는 다양한 기능과 라이브러리에 대한 스타터 패키지를 제공합니다.
      
        이 패키지들을 추가함으로써 필요한 의존성들을 간단하게 설정할 수 있습니다.
      
       예를 들어, 웹 애플리케이션을 개발할 때 spring-boot-starter-web 의존성을 추가하면 필요한 웹 관련 라이브러리들이 함께 추가됩니다.
    
  - 내장된 서버
    
    - 스프링 부트는 내장된 서버(Tomcat, Jetty, Undertow)를 사용하여 웹 애플리케이션을 실행할 수 있습니다.
      
      이로써 별도의 웹 서버 설정 없이도 애플리케이션을 빠르게 실행하고 배포할 수 있습니다.
  
  - 외부 설정 파일
  
  
    - 스프링 부트는 application.properties 또는 application.yml 파일을 통해 애플리케이션의 설정을 관리합니다.
     
      이를 통해 설정을 외부에서 관리하고, 환경별로임.
     
-----------------------------------------------------
##  스프링 부트에서 어노테이션의 작동 원리

- @SpringBootApplication: 스프링 부트 애플리케이션의 주 진입점을 나타내는 어노테이션.
  
    - 이 어노테이션이 붙은 클래스가 실행 시작점이 되며, 스프링 부트 애플리케이션 컨텍스트를 설정함.

- @Controller, @Service, @Repository, @Component: 이러한 어노테이션은 스프링 컨테이너에 해당 클래스를 빈(bean)으로 등록함.
  
    -  빈은 스프링 애플리케이션에서 관리되는 객체로, 다른 빈과의 의존성 주입 등을 통해 사용됨.

- @RequestMapping, @GetMapping, @PostMapping, @PutMapping, @DeleteMapping:
  - 이러한 어노테이션은 컨트롤러 클래스나 메서드에 붙어 웹 요청 URL과 HTTP 메서드와의 매핑을 설정함.
  
  -  예를 들어, @GetMapping("/hello")은 "/hello" URL로 들어오는 GET 요청을 처리하는 메서드를 정의함.

- @Configuration, @Bean: 이 어노테이션은 스프링 빈의 설정을 제어하며, @Configuration 어노테이션이 붙은 클래스 내에서 @Bean 어노테이션을 사용하여 커스텀 빈을 정의함.

- @EnableAutoConfiguration: 스프링 부트의 핵심 기능 중 하나로, 자동 구성을 활성화하는 어노테이션입니다.
  
-  이 어노테이션을 사용하면 스프링 부트가 애플리케이션을 실행할 때 클래스 경로와 설정 정보를 기반으로 자동으로 필요한 빈을 생성하고 구성합니다.

-----------------------------------------------------
## ORM
 - Object-Relational Mapping의 약자로, 객체 지향 프로그래밍 언어(예: Java, C#, Python)와 관계형 데이터베이스 간의 데이터 변환을 자동화하는 프로그래밍 기술 또는 패턴을 가리킵니다.
   
 -  이것은 객체 지향 모델과 관계형 데이터베이스 모델 간에 존재하는 불일치를 해결하고, 객체를 데이터베이스 테이블과 레코드로 매핑하며, 데이터베이스와 상호 작용하는 데 사용됩니다.

- ORM의주요 목표
  
    - 객체 지향 모델과 데이터베이스 모델 간의 불일치 해결: 객체는 상속, 다형성 및 연관관계와 같은 복잡한 구조를 가지고 있지만, 관계형 데이터베이스는 테이블과 로우로 구성되며 정규화된 데이터 구조를 갖고 있습니다. ORM은 이러한 두 모델 간의 불일치를 해결하여 객체와 데이터베이스 간의 매핑을 제공합니다.
  
    - SQL 쿼리 생성 및 실행 자동화: ORM은 개발자가 SQL 쿼리를 직접 작성하지 않고도 객체를 데이터베이스에 저장, 검색, 갱신 및 삭제할 수 있게 합니다. ORM은 객체와 데이터베이스 간의 관계를 관리하고 필요한 SQL 쿼리를 자동으로 생성하여 데이터베이스 조작을 단순화합니다.
  
   - 데이터베이스 독립성 제공: ORM을 사용하면 데이터베이스 시스템에 대한 의존성을 줄일 수 있으며, 애플리케이션을 여러 데이터베이스 시스템 간에 이식할 때 노력을 줄일 수 있습니다.
  
   - 생산성 향상: ORM은 개발자가 데이터베이스와 직접 상호 작용하지 않고도 데이터 액세스 코드를 작성할 수 있게 도와 개발 생산성을 향상시킵니다.
  
  - 유지보수 용이성: 데이터 모델이 변경될 때 ORM은 매핑을 업데이트하고 SQL 쿼리를 자동으로 조정하여 데이터베이스 변경에 대한 작업을 단순화합니다.
  
  - 객체 지향 프로그래밍의 이점 활용: ORM은 객체 지향 프로그래밍 언어의 이점을 살려서 코드를 작성하고 유지하기 쉽게 만듭니다.

- 주요 ORM 프레임워크
  -  Hibernate, Entity Framework (.NET), Django ORM (Python), Sequelize (Node.js), SQLAlchemy (Python), JPA (Java Persistence API)

- ORM vs SQL Mapping
 
  - ORM은 데이터베이스와 객체 간의 불일치를 해결하고 객체 지향 프로그래밍 모델을 촉진하는 데 중점을 둡니다. SQL 쿼리 생성 및 매핑을 자동화하며, 복잡한 객체 간의 관계를 처리하는 데 적합합니다.
  
  - SQL Mapping은 SQL에 대한 직접적인 제어를 허용하며, 개발자가 SQL 쿼리를 명시적으로 정의하고 관리하는 데 유용합니다. 복잡한 SQL 작업을 수행할 때 더 많은 유연성을 제공합니다.
  
  - 선택은 프로젝트의 요구 사항과 개발자 선호에 따라 달라집니다. ORM은 객체 지향적인 개발을 강조하며, SQL Mapping은 SQL 쿼리에 직접적인 제어를 원하는 경우에 더 적합합니다.
    
-----------------------------------------------------
## JPA(Java Persistence API) 
- 자바 애플리케이션에서 데이터베이스와 상호 작용하는데 사용되는 API입니다.
- JPA는 객체-관계 매핑(Object-Relational Mapping, ORM) 기술의 한 형태로, 데이터베이스 테이블과 자바 객체 간의 매핑을 쉽게 처리하여 개발자가 데이터베이스에 접근할 때 SQL 쿼리를 직접 작성하지 않고도 데이터를 조작할 수 있도록 합니다.

Spring에서 JPA를 사용하려면 다음과 같은 주요 컴포넌트와 개념을 이해해야 합니다:

##  Entity 클래스
- JPA를 사용하려면 데이터베이스 테이블과 매핑되는 자바 객체를 정의해야 합니다.
- 이러한 객체를 엔티티(Entity) 클래스라고 하며, @Entity 어노테이션을 사용하여 선언합니다.
  
```
@Entity
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private double price;
    // getter, setter, 기타 메서드
}
```

Repository 인터페이스: 데이터베이스와 상호 작용하기 위한 메서드를 정의한 인터페이스를 생성합니다. 이 인터페이스는 Spring Data JPA에서 제공하는 JpaRepository를 확장할 수 있으며, 자동으로 CRUD(Create, Read, Update, Delete) 작업을 처리합니다.

```
public interface ProductRepository extends JpaRepository<Product, Long> {
    List<Product> findByName(String name);
}
```

- EntityManager: JPA를 사용하여 엔티티와 상호 작용할 때 사용되는 핵심 인터페이스입니다.EntityManager는 엔티티 매니저 팩토리(EntityManagerFactory)를 통해 생성되며, 데이터베이스 트랜잭션을 관리하고 엔티티의 CRUD 작업을 수행합니다.

- Spring Data JPA: Spring Data JPA는 Spring 프레임워크와 JPA를 통합하여 개발자가 더 쉽게 데이터베이스 작업을 처리할 수 있도록 돕는 프로젝트입니다. JpaRepository 인터페이스와 같은 기능을 제공하여 개발자가 반복적인 데이터 액세스 코드를 줄일 수 있습니다.

- JPQL (Java Persistence Query Language): JPA는 데이터베이스와 직접적으로 SQL 쿼리를 사용하지 않고, JPQL이라고 하는 객체 지향 쿼리 언어를 제공합니다. JPQL을 사용하여 엔티티를 검색하고 필터링할 수 있습니다.

- Spring에서 JPA를 사용하는 기본 단계
  -  엔티티 클래스 정의
  -  Repository 인터페이스 생성
  -  Spring 설정에서 JPA 설정 및 데이터베이스 연결 구성
  -  서비스 레이어에서 Repository를 사용하여 데이터 액세스 로직 구현
  -  컨트롤러 레이어에서 서비스를 호출하여 웹 애플리케이션과 통합
  -  Spring Boot를 사용하면 이러한 설정을 자동화하고 간소화할 수 있으며, 다양한 데이터베이스와의 통합도 쉽게 처리할 수 있습니다.
  -  JPA를 효과적으로 사용하기 위해서는 JPA의 다양한 기능과 설정 옵션에 대한 깊은 이해가 필요합니다.


-----------------------------------------------------
## ENTITY 와 DTO의 차이점 
 
- DTO: 데이터 전송 객체로, 주로 데이터를 전달하고 전송하는 목적을 가집니다.
  주로 외부 시스템과의 데이터 교환 및 원격 프로시저 호출 등에서 사용됩니다.
- ENTITY: 데이터베이스와 직접 매핑되는 객체로, 데이터베이스 엔티티를 표현하고 비즈니스 논리와 관련된 데이터를 저장하고 관리하는 데 사용됩니다.
  
- 데이터 저장 위치:
  - DTO: 주로 데이터 전송을 위해 사용되며, 데이터를 일시적으로 저장하고 전달하기 위한 용도로 사용됩니다. 따라서 일반적으로 데이터베이스에 저장되지 않습니다.
  - ENTITY: 데이터베이스에 저장되는 정보를 나타내며, 영구적인 데이터를 데이터베이스에 저장하고 관리하기 위해 사용됩니다.

  
- 데이터 변경 가능성:
  - DTO: 일반적으로 불변(Immutable)하며 데이터 전송을 위한 목적으로 만들어집니다. 즉, 데이터를 변경하지 않는 것이 일반적입니다.
  - ENTITY: 데이터베이스의 데이터를 나타내므로 데이터의 변경이 필요한 경우, 업데이트를 통해 데이터베이스에 반영됩니다.

- 비즈니스 로직:
    - DTO: 주로 데이터 전송에 관련된 로직을 가지지 않으며, 데이터의 전송 및 변환에 집중합니다.
    - ENTITY: 비즈니스 로직과 관련된 메서드를 포함할 수 있으며, 데이터와 관련된 비즈니스 규칙을 구현하는 데 사용됩니다.

- 데이터 전송과 변환:
    - DTO: 다른 시스템 또는 레이어 간에 데이터를 전송하고 변환하는 데 사용됩니다. 예를 들어, 클라이언트와 서버 간의 데이터 전송 및 웹 API에서 사용됩니다.
    - ENTITY: 주로 데이터베이스와의 상호작용에 사용되며, 데이터베이스 스키마와 일치하고 데이터의 영속성을 관리합니다.
      
- 패키지 및 계층 구조:
  - DTO: 주로 웹 계층(웹 컨트롤러와 같은)에서 사용되며, 컨트롤러와 뷰 간에 데이터 전송을 담당하는 패키지에서 정의됩니다.
  - ENTITY: 주로 데이터 액세스 계층에서 사용되며, 데이터베이스 엔티티를 정의하고 데이터의 영속성을 관리하는 패키지에서 정의됩니다.
  
요약하면, DTO는 데이터 전송 및 변환을 위해 사용되며 주로 외부 시스템과의 데이터 통신에 사용되는 일시적인 데이터 객체입니다.

 반면 ENTITY는 데이터베이스와 직접 상호작용하고 비즈니스 논리와 데이터 영속성을 관리하기 위한 객체로, 데이터베이스와 관련된 영구적인 데이터를 나타내는 엔티티입니다.
